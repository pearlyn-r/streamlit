import os
import pandas as pd
from datetime import datetime, timedelta
import openpyxl
from openpyxl.utils.dataframe import dataframe_to_rows
import shutil

def get_all_csv_files(folder_path):
    """Get all CSV files in the folder"""
    csv_files = []
    for filename in os.listdir(folder_path):
        if filename.endswith('.csv'):
            csv_files.append(filename)
    return csv_files

def get_date_from_csv(file_path):
    """Extract date from cell J2 (column J, row 2) in CSV file"""
    try:
        # Read CSV file
        df = pd.read_csv(file_path)
        
        # Check if we have at least 10 columns (J is the 10th column, index 9)
        if len(df.columns) < 10:
            print(f"CSV file {file_path} doesn't have column J")
            return None
        
        # Check if we have at least 2 rows (index 1 for row 2)
        if len(df) < 2:
            print(f"CSV file {file_path} doesn't have row 2")
            return None
        
        # Get value from J2 (column index 9, row index 1)
        date_value = df.iloc[1, 9]  # Row 2, Column J
        
        if pd.isna(date_value):
            print(f"No date found in J2 of {file_path}")
            return None
        
        # Try to parse the date
        if isinstance(date_value, str):
            try:
                return datetime.strptime(date_value, "%m/%d/%Y")
            except ValueError:
                # Try other common date formats
                try:
                    return pd.to_datetime(date_value).to_pydatetime()
                except:
                    print(f"Could not parse date '{date_value}' from {file_path}")
                    return None
        else:
            # If it's already a datetime-like object
            try:
                return pd.to_datetime(date_value).to_pydatetime()
            except:
                print(f"Could not parse date '{date_value}' from {file_path}")
                return None
                
    except Exception as e:
        print(f"Error reading date from {file_path}: {e}")
        return None

def rename_csv_files(folder_path):
    """Rename CSV files based on date in J2 cell"""
    renamed_files = []
    
    for filename in os.listdir(folder_path):
        if filename.endswith('.csv'):
            file_path = os.path.join(folder_path, filename)
            
            # Get date from J2 cell
            file_date = get_date_from_csv(file_path)
            
            if file_date:
                # Format new filename as file_yyyymmdd.csv
                new_filename = f"file_{file_date.strftime('%Y%m%d')}.csv"
                new_file_path = os.path.join(folder_path, new_filename)
                
                # Rename the file
                try:
                    os.rename(file_path, new_file_path)
                    renamed_files.append((new_file_path, file_date))
                    print(f"Renamed: {filename} -> {new_filename}")
                except Exception as e:
                    print(f"Error renaming {filename}: {e}")
            else:
                print(f"Could not process {filename} - no valid date found")
    
    return renamed_files

def extract_data_from_csv(file_path):
    """Extract data from columns A, B, E, G, N starting from row 3"""
    try:
        # Read CSV file, skip first 2 rows (start from row 3)
        df = pd.read_csv(file_path, skiprows=2)
        
        # Check if we have enough columns
        if len(df.columns) < 14:  # N is the 14th column (index 13)
            print(f"CSV file {file_path} doesn't have enough columns")
            return None
        
        # Extract columns A, B, E, G, N (indices 0, 1, 4, 6, 13)
        selected_columns = df.iloc[:, [0, 1, 4, 6, 13]].copy()
        
        # Rename columns to match A, B, E, G, N
        selected_columns.columns = ['A', 'B', 'E', 'G', 'N']
        
        # Remove any completely empty rows
        selected_columns = selected_columns.dropna(how='all')
        
        return selected_columns
    except Exception as e:
        print(f"Error extracting data from {file_path}: {e}")
        return None

def refresh_pivot_table(workbook, sheet_name='Sheet2'):
    """Refresh pivot table in specified sheet"""
    try:
        worksheet = workbook[sheet_name]
        # Get all pivot tables in the worksheet
        for pivot_table in worksheet._pivots:
            pivot_table.cache.refreshOnLoad = True
        print(f"Pivot table in {sheet_name} marked for refresh")
    except Exception as e:
        print(f"Error refreshing pivot table: {e}")

def process_files(folder_path, template_path):
    """Main function to process all files"""
    
    # Get all CSV files in the folder
    csv_files = get_all_csv_files(folder_path)
    
    print(f"Found {len(csv_files)} CSV files in the folder:")
    for i, filename in enumerate(csv_files, 1):
        print(f"{i}. {filename}")
    
    if not csv_files:
        print("No CSV files found in the folder.")
        return
    
    print(f"\nProcessing {len(csv_files)} files...")
    
    # Rename files based on date in J2
    renamed_files = rename_csv_files(folder_path)
    
    if not renamed_files:
        print("No files could be processed (no valid dates found).")
        return
    
    # Process each renamed file
    for file_path, file_date in renamed_files:
        print(f"\nProcessing: {os.path.basename(file_path)}")
        
        # Extract data from columns A, B, E, G, N
        extracted_data = extract_data_from_csv(file_path)
        
        if extracted_data is None or extracted_data.empty:
            print(f"No data extracted from {file_path}")
            continue
        
        # Create a copy of the template file
        date_str = file_date.strftime('%Y%m%d')
        summary_filename = f"summary_{date_str}.xlsx"
        summary_path = os.path.join(folder_path, summary_filename)
        
        try:
            # Copy template file
            shutil.copy2(template_path, summary_path)
            
            # Load the workbook
            wb = openpyxl.load_workbook(summary_path)
            
            # Clear existing data in Sheet1 and paste new data
            sheet1 = wb['Sheet1']
            
            # Clear all data in Sheet1
            sheet1.delete_rows(1, sheet1.max_row)
            
            # Add column headers
            headers = ['A', 'B', 'E', 'G', 'N']
            for col_idx, header in enumerate(headers, 1):
                sheet1.cell(row=1, column=col_idx, value=header)
            
            # Add extracted data
            for row_idx, row in enumerate(dataframe_to_rows(extracted_data, index=False, header=False), 2):
                for col_idx, value in enumerate(row, 1):
                    sheet1.cell(row=row_idx, column=col_idx, value=value)
            
            print(f"Data pasted to Sheet1: {len(extracted_data)} rows")
            
            # Select all data in Sheet1 before refreshing pivot table
            max_row = sheet1.max_row
            max_col = sheet1.max_column
            data_range = f"A1:{openpyxl.utils.get_column_letter(max_col)}{max_row}"
            
            # Refresh pivot table in Sheet2
            refresh_pivot_table(wb, 'Sheet2')
            
            # Save the file
            wb.save(summary_path)
            wb.close()
            
            print(f"Summary file created: {summary_filename}")
            
        except Exception as e:
            print(f"Error creating summary file for {file_path}: {e}")

def main():
    """Main execution function"""
    
    # Get user inputs
    folder_path = input("Enter the folder path containing CSV files: ").strip()
    template_path = input("Enter the path to the template Excel file: ").strip()
    
    # Validate folder path
    if not os.path.exists(folder_path):
        print(f"Folder path does not exist: {folder_path}")
        return
    
    # Validate template path
    if not os.path.exists(template_path):
        print(f"Template file does not exist: {template_path}")
        return
    
    # Process files
    process_files(folder_path, template_path)
    
    print("\nProcessing completed!")

if __name__ == "__main__":
    main()
